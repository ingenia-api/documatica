$: << '../../lib'

$LOAD_PATH << '.'
require 'bundler/setup'
require 'doc_smoosher'

extend DocSmoosher::TopLevel

# Shared fields
limit = define_parameter( name: 'limit' ) do |p|
  p.description = 'Return these many results'
  p.type = :integer
  p.default = 50
end

offset = define_parameter( name: 'offset' ) do |p|
  p.description = 'Offset the results I receive by this amount'
  p.type = :integer
  p.default = 0
end

full_text = define_parameter( name: 'full_text' ) do |p|
  p.description = 'Show the results with all their text, however long'
  p.type = :boolean
  p.default = '0'
end

##
# Introduction 
#

DESCRIPTION =<<-DESC
  <p>Check out the <a href="/pages/demo"> demo </a> to see Ingenia in action.</p>

  <p>Look at the <a href="/faq">FAQ</a> for any questions.</p>

  <p> Go through the documentation and choose if you want to use Ingenia by the API or with one of the libraries. </p>

  <p> <a href="/contact"> Contact us </a> to get your API key or if you have any questions.</p>

  <p>If you would like to verify your API key or code data path then use the <a href="#call-administrative-calls-status">status</a> call.</p>

  <h3 id='api-libraries'>Ruby API library</h3>
  <a href="https://github.com/ingenia-api/ingenia_ruby">https://github.com/ingenia-api/ingenia_ruby</a>

  <h3 id='api-rate-limiting'>Rate limiting</h3>

  <p>Ingenia by default limits a user to 4 calls per second, for every type of API call. Contact us to have this limit increased or removed if needed. </p>
DESC

json_similarity_response = define_object( name: 'Similarity response' ) do |sr|

  sr.description = "An array of item matches to the similarity call"

  sr.parameter name: 'id' do |p|
    p.description = 'The ID of the item. (either created by user or generated by the system)'
    p.type = :string
  end

  sr.parameter name: 'text' do |p|
    p.description = 'Text of item, only first 50 characters'
    p.type = :string
  end

  sr.parameter name: 'mode' do |p|
    p.description = 'Is either tag or word.'
    p.type = :string
  end

  sr.parameter name: 'similarity' do |p|
    p.description = 'Score of similarity to source. 0=low, 1=high'
    p.type = :string
  end

  sr.example = '
  {
    [
      { "item": { "id":12182, "text": "The fall in the rand has given wealthy Russians a new location to search for luxury..." }, "mode": "tag", "similarity": 0.62144 },
      { "item": { "id":9293, "text": "Robots tend to do jobs that no one wants to do. I am old enough to remember..."  }, "mode": "tag", "similarity": 0.62174 },
      { "item": { "id":25333, "text": "The market for RMB credit raised outside China has gone four weeks without a..." }, "mode": "word", "similariy": 0.62174 }
    ]
  }'
end

# bundle
json_bundle = define_object( name: 'Bundle create / update input' ) do |bundle|
  bundle.description = "A collection of items related to each other"

  bundle.parameter name: 'name' do |p|
    p.description = 'The name of your bundle'
    p.type = :string
  end

  bundle.this_is_json!

  bundle.parameter name: 'tag_set_ids' do |p|
    p.description =<<-DESC
    An array of tag set IDs to be applied to this bundle. The tags in these tag sets will be available to the items in the bundle.
    If an existing bundle already has tag sets, then these can be removed by omitting the ID in the call.
    DESC
    p.type = :array
  end

  bundle.example = '
  {
    "name":"Tech Startups",
    "tag_set_ids": [ 232, 332, 6582 ]
  }'
end

json_bundle_show = define_object( name: 'Bundle show output' ) do |bundle|
  bundle.description = "A collection of items related to each other"

  bundle.parameter name: 'name' do |p|
    p.description = 'The name of your bundle'
    p.type = :string
  end

  bundle.parameter name: 'tag_sets' do |ts|
    ts.description = 'The tag sets that are currently attached to this bundle. Items within the bundle can use all the tags in these tag sets.'
    ts.type = :array
  end
  
  bundle.example = '
  {
    "id":47858,
    "name":"Tech Startups",
    "tag_sets": [
      { "name": "technology", "id": 14562 },
      { "name": "business", "id": 666 }
    ]
    "created_at":"2014-03-13T15:36:51Z",
    "updated_at":"2014-03-13T15:36:51Z",
  }'
end

json_basic_response = define_object( name: 'Basic response format' ) do |brf|
  
  brf.description = "All responses from the API gateway have the following format"

  brf.parameter name: 'version' do |p|
    p.description = 'The version of the API that is responding'
    p.type = :string
    p.example = '"2.0"'
  end

  #data
  brf.parameter name: 'data' do |p|
    p.description = 'The data payload response from the call'
    p.type = :object
  end


  #status
  brf.parameter name: 'status' do |p|
    p.description = '"okay" if the call is processed correctly, otherwise will be "error"'
    p.type = :thing
  end

  #message
  brf.parameter name: 'message' do |p|
    p.description = 'Message text describing nature of error. Only returned if an error occurred'
    p.type = :thing
  end

end

# Item JSON POST form
json_item = define_object( name: 'Item create / update input' ) do |item|
  item.description = "An item is a block of text to which you can associate tags"

  item.this_is_json!

  item.parameter name: 'id' do |p|
    p.description = 'A unique text/numeric id. You can use your own, or have Ingenia generate one for you'
    p.default = '[generated]'
    p.type = :string
    p.example = '785uU423aC'
  end

  item.parameter name: 'text' do |p|
    p.description = 'Your item\'s content. (See notes in Item create call)'
    p.type = :string
  end

  item.parameter name: 'url' do |p|
    p.description = 'Source URL to pull text from. (See notes in Item create call)'
    p.type = :string
    p.example = 'http://example.com'
  end

  item.parameter name: 'bundle_id' do |p|
    p.description = 'ID of bundle to put item into'
    p.type = :integer
    p.example = '45798'
    p.default = '[user\'s first bundle]'
  end

  item.parameter name: 'tags' do |p|
    p.description = "The name of tags you wish applied to this item. Tags will be looked for first, then created if they do not exist. (Note 1)"
    p.type = :array
    p.example = '[ "startups", "saas", "marketing" ]'
  end

  item.parameter name: 'tag_ids' do |p|
    p.description = "The Ingenia IDs of the tags you want to have associated with this item. (Note 1)"
    p.type = :array
    p.example = '[ 45, 787, 23 ]'
  end

  item.parameter name: 'tag_sets' do |p|
    p.description = "Groups of tags that you consider of the same type; tags will be returned as belonging to a tag set. (Note 1)"
    p.type = :hash
    p.example = '{ "topics": [ "startups", "saas", "marketing" ], "geography": [ "united kingdom" ] }'
  end

  item.example = '
  {
    text: "High tech startups and their positive power to change for the good",
    tag_sets: {
      "Business": [ "startups", "business" ],
      "Economics": [ "technology"],
      "Mood": [ "positive" ]
    }
  }
  '

  item.footnote = "Note 1: Only specify one of the following: tags, tag_ids or tag_sets"

end

# Item JSON get form
json_item_show = define_object( name: 'Item show output' ) do |item|
  item.parameter name: 'id' do |p|
    p.description = 'A unique text/numeric id. You can use your own, or have Ingenia generate one for you'
    p.type = :string
    p.example = '785uU423aC'
  end

  item.parameter name: 'text' do |p|
    p.description = 'Your item\'s textual content'
    p.type = :string
  end

  item.parameter name: 'created_at' do |p|
    p.description = 'When this item was created'
    p.type = :date_time
    p.example = '2013-12-16T11:24:52+00:00'
  end

  #We should probably not show this to the user
  item.parameter name: 'updated_at' do |p|
    p.description = 'When this item was last updated'
    p.type = :date_time
    p.example = '2013-12-16T11:25:52+00:00'
  end

  item.parameter name: 'last_classified_at' do |p|
    p.description = 'When this item was last classified by the system, or null if it hasn\'t been classified yet'
    p.type = :date_time
    p.example = '2013-12-16T11:25:52+00:00'
  end


  item.example = '
  {
    "id":"e19e134d0e79153349ff78a674283e0b",
    "last_classified_at":2013-12-16T11:25:07+00:00,
    "text":"How to get to scale with a saas startup in the UK? etc",
    "tag_sets":
      [
        {
          "topics":
          {
            "id":156,
            "tags":
              [
                {
                  "id":4352,
                  "name":"startups",
                  "score":"0.8",
                  "user_selected": "f"
                },
                {
                  "id":7811,
                  "name":"saas",
                  "score":"0.45",
                  "user_selected": "t"
                },
                {
                  "id":1327,
                  "name":"marketing",
                  "user_selected": "t"
                }
              ]
          }
        },
        {
          "geography":
          {
            "id":622,
            "tags":
              [
                {
                  "id":3321,
                  "name":"united kingdom",
                  "score":"0.37",
                  "user_selected": "f"
                }
              ]
          }
        }
      ]
    "created_at":"2013-12-16T11:24:52+00:00",
    "updated_at":"2013-12-16T11:24:56+00:00"
  }'
end

# Tag JSON POST form
json_tag = define_object( name: 'Tag create / update input' ) do |tag|
  tag.description = "Something you want to associate to an item, e.g., a concept, topic, tone, sentiment, keyword, person, company, product, etc."

  tag.this_is_json!

  tag.parameter name: 'name' do |p|
    p.description = 'The name of your tag'
    p.type = :string
    p.required = true
  end

  tag.parameter name: 'tag_set_id' do |p|
    p.description = 'The ID of the tag_set to which this tag belongs'
    p.type = :integer
    p.example = '3787'
    p.required = true
  end

  tag.parameter name: 'description' do |p|
    p.description = "A description of this tag"
    p.type = :string
  end

  tag.parameter name: 'disposition' do |p|
    p.description = "The disposition of the tag. Float value between 0 and 1, defaults to 0.5. Lower values will tend to privilege precision (we suggest 0.25); higher values will tend to privilege recall (we suggest 0.75). For most uses, the default value will work well.

You will want to privilege precision (with a disposition < 0.5) if you want each tag assignment to be accurate, and are less worried about some items being missed, i.e., you prefer to have false negatives than false positives. If the disposition is 0, no item will be tagged with this tag.

You will want to privilege recall (with a disposition > 0.5) if you want each tag assignment to occur, and are less worried about some items being tagged incorrectly, i.e., you prefer to have false positives than false negatives. If the disposition is 1, all items will be tagged with this tag."
    p.type = :float
    p.example = 0.75
    p.default = 0.5
  end

  tag.example = '
  {
    "name":"Text Analytics",
    "tag_set_id":37874,
    "description":"",
    "disposition": 0.3
  }'
end

json_tag_show = define_object( name: 'Tag show output' ) do |tag|
  tag.description = "Something you want to associate to an item, e.g., a concept, topic, tone, sentiment, keyword, person, company, product, etc."

  tag.parameter name: 'name' do |p|
    p.description = 'The name of your tag'
    p.type = :string
  end

  tag.parameter name: 'tag_set_id' do |p|
    p.description = 'The ID of the tag_set to which this tag belongs'
    p.type = :integer
    p.example = '3787'
  end

  tag.parameter name: 'confidence' do |p|
    p.description = "Higher if Ingenia understands this tag; from 0 to 1"
    p.type = :float
  end

  tag.parameter name: 'consistency' do |p|
    p.description = "Higher if the tag has been applied to items that are very similar to one another; from 0 to 1"
    p.type = :float
  end

  tag.parameter name: 'description' do |p|
    p.description = "A description of this tag"
    p.type = :string
  end

  tag.parameter name: 'disposition' do |p|
    p.description = "The disposition of the tag. Float value between 0 and 1, defaults to 0.5. Lower values will tend to privilege precision (we suggest 0.25); higher values will tend to privilege recall (we suggest 0.75). For most uses, the default value will work well.

You will want to privilege precision (with a disposition < 0.5) if you want each tag assignment to be accurate, and are less worried about some items being missed, i.e., you prefer to have false negatives than false positives. If the disposition is 0, no item will be tagged with this tag.

You will want to privilege recall (with a disposition > 0.5) if you want each tag assignment to occur, and are less worried about some items being tagged incorrectly, i.e., you prefer to have false positives than false negatives. If the disposition is 1, all items will be tagged with this tag."
    p.type = :float
    p.example = 0.75
  end

  tag.example = '
  {
    "id":554273,
    "name":"Text Analytics",
    "tag_set_id":8547,
    "confidence":0.95,
    "consistency":0.92,
    "description":"",
    "created_at":"2014-03-13T12:59:32Z",
    "updated_at":"2014-03-13T12:59:32Z"
  }'
end

# TagSet JSON POST form
json_tag_set = define_object( name: 'Tag set create / update input' ) do |tag_set|
  tag_set.description = "A collection of thematically consistent tags"
  tag_set.this_is_json!

  tag_set.parameter name: 'name' do |p|
    p.description = 'The name of your tag set'
    p.type = :string
  end

  tag_set.example = '
  {
    "name":"Big Data"
  }'
end

json_tag_set_show = define_object( name: 'Tag set show output' ) do |tag_set|
  tag_set.description = "A collection of thematically consistent tags"
  tag_set.parameter name: 'name' do |p|
    p.description = 'The name of your tag set'
    p.type = :string
  end

  tag_set.example = '
  {
    "id":178751,
    "name":"Big Data",
    "created_at":"2014-03-12T12:17:33Z",
    "updated_at":"2014-03-12T12:17:33Z"
  }'
end

# Classifications
json_classify = define_object( name: 'Classifications' ) do |classify|

    classify.example = '
{
  "api_version": "1.0",
  "status": "okay",

  "data": {
    "classification_status": "complete",
    "results": {

      "Software": {
        "id": 6,
        "tags": [
          {
            "id": 31,
            "name": "php",
            "score": 0.655
          },
          {
            "id": 90,
            "name": "php-session",
            "score": 0.315
          },
          {
            "id": 158,
            "name": "pass-by-reference",
            "score": 0.262
          },
          {
            "id": 160,
            "name": "debugging",
            "score": 0.24
          },
          {
            "id": 159,
            "name": "pass-by-value",
            "score": 0.198
          },
          {
            "id": 63,
            "name": "apache",
            "score": 0.132
          }
        ]
      }
    }
  }
}
'

end






define_api( name: 'Ingenia API', description: DESCRIPTION ) do |api|

  api.endpoint = 'api.ingeniapi.com/v2/'
  api.version = '2.0'
  api.format = 'json'

  api.object json_basic_response
  api.object json_item 
  api.object json_item_show 
  api.object json_bundle
  api.object json_bundle_show
  api.object json_tag
  api.object json_tag_show
  api.object json_tag_set
  api.object json_tag_set_show
  api.object json_similarity_response


  api.resource name: 'Classifications' do |r|
    r.description = ""
    
    r.request name: 'Classify' do |req|
      req.description = ''
      req.call_type = :post
      req.path = '/classify'

      req.parameter name: 'api_version' do |p|
        p.description = 'The version of the API to use'
        p.type = :integer
      end

      req.parameter name: 'min_tags' do |p|
        p.description = 'Return at least these many tags'
        p.type = :integer
        p.default = 0
      end

      req.parameter name: 'max_tags' do |p|
        p.description = 'Return at most these many tags'
        p.type = :integer
      end

      req.parameter name: 'text' do |p|
        p.description = 'The text you want Ingenia to classify. (See Item create notes)'
        p.type = :string
        p.example = 'A comparative study of European secondary education systems illustrated issues related to their budgetary sustainability...'
      end

      req.parameter name: 'url' do |p|
        p.description = 'Source URL to read text from and classify from. (See Item create notes)'
        p.type = :string
        p.example = 'http://example.com'
      end

      req.parameter name: 'file' do |p|
        p.description = 'Source document sent as multi-part form submission. (See Item creat notes)'
        p.type = :multipart
        p.example = 'document.pdf'
      end

    end


  end





  ##
  # Recommendation Engine
  #
 
  api.resource name: 'Recommendation engine' do |r|
    r.description = ""
    
    r.request name: 'Similar_to_text' do |req|
      req.description = ''
      req.call_type = :get
      req.path = '/similar_to_text'

      req.parameter name: 'limit' do |p|
        p.description = 'Maximum number of items to return'
        p.type = :integer
        p.default = '10'
      end

      req.parameter name: 'full_text' do |p|
        p.description = 'Return full text of item on Ingenia'
        p.type = :integer
        p.default = '1'
      end

      req.parameter name: 'text' do |p|
        p.description = 'Text to use as a starting point'
        p.type = :string
      end

      req.response = json_similarity_response
    end

    
    r.request name: 'Similar_to_tags' do |req|
      req.description = ''
      req.call_type = :get
      req.path = '/similar_to_tags'

      req.parameter name: 'limit' do |p|
        p.description = 'Maximum number of items to return'
        p.type = :integer
        p.default = '10'
      end

      req.parameter name: 'tag_set_count' do |p|
        p.description = 'Return full text of item on Ingenia'
        p.type = :integer
        p.default = '1'
      end

      req.parameter name: 'tag_ids' do |p|
        p.description = 'JSON encoded array of tag IDs to use as starting point'
        p.type = :array
      end      

      req.response = json_similarity_response
    end


    r.request name: 'Similar_to_items' do |req|
      req.description = ''
      req.call_type = :get
      req.path = '/similar_to_item'

      req.parameter name: 'limit' do |p|
        p.description = 'Maximum number of items to return'
        p.type = :integer
        p.default = '10'
      end

      req.parameter name: 'tag_set_count' do |p|
        p.description = 'Return full text of item on Ingenia'
        p.type = :integer
        p.default = '1'
      end

      req.parameter name: 'item_ids' do |p|
        p.description = 'JSON encoded array of tag IDs to use as starting point'
        p.type = :array
      end
      req.response = json_similarity_response

    end
  end

  ##
  # Summarization
  #
  api.resource name: 'Summarization' do |r|
    r.description = ""
    
    r.request name: 'Summarise' do |req|
      req.description = ''
      req.call_type = :post
      req.path = '/summarise'

      req.parameter name: 'text' do |p|
        p.description = 'text to summarise'
        p.type = :string
      end

      req.parameter name: 'include_tags' do |p|
        p.description = 'If true the results be organised by tag, if false they are returned as a list'
        p.type = :boolean
        p.default = true
      end

      req.parameter name: 'max_sentences' do |p|
        p.description = 'Maximum number of sentences to return'
        p.type = :integer
        p.default = 2
      end

      req.parameter name: 'order_by_position' do |p|
        p.description = 'If true, the results will be ordered as they appear in the text, if false, they will be ordered by score.'
        p.type = :boolean
        p.default = false
      end


    end

  end


  ##
  # Items
  #
  api.resource name: 'Items' do |r|
    r.description = "Blocks of textual content, typically self-contained and homogeneous"
    
    r.request name: 'Index' do |req|
      req.description = 'Returns a list of all your items'
      req.call_type = :get
      req.path = '/items'

      
      req.parameter limit
      req.parameter full_text
      req.parameter offset

      #req.response = { :array => json_item_show.example }
    end


    r.request name: 'Show' do |req|
      req.description = 'Returns a single item'
      req.call_type = :get
      req.path = '/items/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the item you want to show'
        p.type = :string
        p.example = '3casjghd67'
        p.required = true
      end
      
      req.parameter full_text

      req.response = json_item_show
    end

    r.request name: 'Create' do |req|
      req.description = 'Creates a new item'
      req.call_type = :post
      req.path = '/items'

      req.parameter name: 'file' do |p|
        p.description = 'File to be used as text source. Sent as multipart upload. Accepted file types are: Text (txt), Postscript Document Format (pdf), Microsoft Office Documents (doc, docx, xls, xlsx, ppt, pptx). (See notes below)'
        p.type = :multipart
      end

      req.parameter name: 'update_existing' do |p|
        p.description = 'Choice of what to do if the text sent via a create call already exists on Ingenia. If true, the tags supplied will overwrite those on the existing item (default). If false, no data is modified and a response is returned with a 409 code (Conflict) together with the existing item as JSON.'
        p.default = true
      end

      req.parameter name: 'classify' do |p|
        p.description = 'If true, the response will also include a classification.'
        p.default = '0'
      end

      req.parameter name: 'file' do |p|
        p.description = 'File to be used as text source. Sent as multipart upload. Accepted file extensions are; Text (txt), Postscript Document Format (pdf) and Microsoft Office Documents (doc, docx, xlsx, ppt, pptx).'
      end

      req.parameter json_item

      req.footnote =<<-FN
        <p>Note: you can input content as ONE of: text, a URL, a file (formats
        supported include txt, html, pdf, all the MS Office formats). If you
        send a URL, Ingenia will extract the most meaningful text from it,
        e.g., ignoring links. If you send a file, it will extract the text
        from it.</p>
        <p>The text and the URL are input as part of the JSON component. The file
        is sent as a multipart encoded http field.</p>
      FN
#
#        Notes: at least one input (text, url, file) field is required. If more inputs are sent, fields are selected in the following order: text, url, file.
#
#        Notes: if the input already exists in your Ingenia account, this call will act like an 'update'. Warning: it will delete the previous tags, and apply the new ones you've sent
#       "
    end

    r.request name: 'Update' do |req|
      req.description = 'Update an existing item'
      req.call_type = :put
      req.path = '/items/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the item you want to update.'
        p.type = :string
        p.example = '3casjghd67'
        p.required = true
      end

      req.parameter name: 'file' do |p|
        p.description = 'File to be used as text source. Sent as multipart upload. Accepted file types are: Text (txt), Postscript Document Format (pdf), Microsoft Office Documents (doc, docx, xls, xlsx, ppt, pptx). (See Item create call notes)'
        p.type = :multipart
      end

      
      req.parameter json_item
      req.parameter name: 'file' do |p|
        p.description = 'File to be used as text source. Sent as multipart upload. Accepted file extensions are: Text (txt), Postscript Document Format (pdf), Microsoft Office Documents (doc, docx, xls, xlsx, ppt, pptx)'
        p.type = :multipart
      end
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing item'
      req.call_type = :delete
      req.path = '/items/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the item you want to delete.'
        p.type = :string
        p.example = '3casjghd67'
        p.required = true
      end
    end
  end

  ##
  # Bundles
  #
  api.resource name: 'Bundles' do |r|
    r.description = "Groups of thematically consistent items"
    
    r.request name: 'Index' do |req|
      req.description = 'Returns a list of all your bundles'
      req.call_type = :get
      req.path = '/bundles'

      req.parameter limit
      req.parameter offset
    end

    r.request name: 'Show' do |req|
      req.description = 'Returns a single bundle'
      req.call_type = :get
      req.path = '/bundles/:id'
      
      req.parameter name: 'id' do |p|
        p.description = 'The ID of the bundle you want to show'
        p.type = :integer
        p.example = 2314
        p.required = true
      end

      req.response = json_bundle_show
    end

    r.request name: 'Find_by_name' do |req|
      req.description = 'Looks for a bundle that matches text input'
      req.call_type = :get
      req.path = '/bundles/find_by_name'
      
      req.parameter name: 'text' do |p|
        p.description = 'Text of bundle to look for'
        p.type = :string
        p.example = '"Tech Startups"'
      end
    end

    r.request name: 'Create' do |req|
      req.description = 'Creates a new bundle'
      req.call_type = :post
      req.path = '/bundles'
      
      req.parameter json_bundle
    end

    r.request name: 'Update' do |req|
      req.description = 'Update an existing bundle'
      req.call_type = :put
      req.path = '/bundles/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the bundle you want to update.'
        p.type = :integer
        p.example = 5611
        p.required = true
      end
      
      req.parameter json_bundle
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing bundle'
      req.call_type = :delete
      req.path = '/bundles/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the bundle you want to delete.'
        p.type = :string
        p.example = 'gqj78219nc'
        p.required = true
      end
      
    end
  end

  ##
  # Tags
  #
  api.resource name: 'Tags' do |r|
    r.description = "Tags are meaningful words or expressions that you want to associate to some of your items"
    
    r.request name: 'Index' do |req|
      req.description = 'List all your tags'
      req.call_type = :get
      req.path = '/tags'
      
      req.parameter limit
      req.parameter offset
    end

    r.request name: 'Show' do |req|
      req.description = 'View a single tag'
      req.call_type = :get
      req.path = '/tags/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag you want to show'
        p.type = :integer
        p.example = '42'
        p.required = true
      end
      req.response = json_tag_show

    end

    r.request name: 'Find_by_name' do |req|
      req.description = 'Looks for a tag that matches text input'
      req.call_type = :get
      req.path = '/tags/find_by_name'

      req.parameter name: 'text' do |p|
        p.description = 'Text of tag to look for'
        p.type = :string
        p.example = '"Tech Startups"'
      end
    end

    r.request name: 'Create' do |req|
      req.description = 'Create a new tag'
      req.call_type = :post
      req.path = '/tags'

      req.parameter json_tag
    end

    r.request name: 'Update' do |req|
      req.description = 'Update an existing tag'
      req.call_type = :put
      req.path = '/tags/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag you want to update'
        p.type = :integer
        p.example = '42'
        p.required = true
      end
      req.parameter json_tag
    end

    r.request name: 'Merge' do |req|
      req.description = 'Merge two or more existing tags'
      req.call_type = :put
      req.path = '/tags/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag into which you want to merge other tags; the resulting tag will have this name'
        p.type = :integer
        p.example = '42'
        p.required = true
      end

      req.parameter name: 'tag_ids' do |p|
        p.description = 'An array of tag IDs that will be merged into the main tag'
        p.type = :integer
        p.example = '[ 23, 43, 2113 ]'
        p.required = true
      end
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing tag'
      req.call_type = :delete
      req.path = '/tags/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag you want to delete'
        p.type = :integer
        p.example = '42'
        p.required = true
      end
    end
  end

  ##
  # Tag Sets
  #
  api.resource name: 'Tag sets' do |r|
    r.description = "Tag sets are thematically consistent groups of tags, such as, say, world countries, business sectors, product types, companies, concepts, topics, etc"
    
    r.request name: 'Index' do |req|
      req.description = 'List all your tag sets'
      req.call_type = :get
      req.path = '/tag_sets'
 
      req.parameter limit
      req.parameter offset
    end

    r.request name: 'Show' do |req|
      req.description = 'View a single tag set'
      req.call_type = :get
      req.path = '/tag_sets/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag set you want to show'
        p.type = :integer
        p.example = '412'
        p.required = true
      end
      req.response = json_tag_set_show

    end

    r.request name: 'Find_by_name' do |req|
      req.description = 'Looks for a tag set that matches text input'
      req.call_type = :get
      req.path = '/tag sets/find_by_name'

      req.parameter name: 'text' do |p|
        p.description = 'Text of tag set to look for'
        p.type = :string
        p.example = '"Tech Startups"'
      end
    end

    r.request name: 'Create' do |req|
      req.description = 'Create a new tag set'
      req.call_type = :post
      req.path = '/tag_sets'

      req.parameter json_tag_set
    end

    r.request name: 'Update' do |req|
      req.description = 'Update an existing tag set'
      req.call_type = :put
      req.path = '/tag_sets/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag set you want to update'
        p.type = :integer
        p.example = '412'
        p.required = true
      end

      req.parameter json_tag_set
    end

    r.request name: 'Merge' do |req|
      req.description = 'Merge two or more existing tag sets'
      req.call_type = :put
      req.path = '/tag_sets/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag set into which you want to merge the other tag sets; the resulting tag set will have this name'
        p.type = :integer
        p.example = '412'
        p.required = true
      end
      
      req.parameter name: 'tag_set_ids' do |p|
        p.description = 'JSON encoded tag set IDs to merge into request tag set'
        p.type = :integer
        p.example = '[ 12, 34, 56 ]'
        p.required = true
      end
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing tag set'
      req.call_type = :delete
      req.path = '/tag_sets/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag set you want to delete.'
        p.type = :integer
        p.example = '412'
        p.required = true
      end
    end
  end

  ##
  # Administrative Calls
  #
  api.resource name: 'Administrative Calls' do |r|
    r.description = ""
    
    r.request name: 'Status' do |req|
      req.description = 'Use this to test your API key, see [status call] for details'
      req.call_type = :get
      req.path = '/status'

      req.parameter name: 'total_items' do |p|
        p.description = 'Number of items you have created'
        p.type = :integer
        p.example = '1554'
      end

      req.parameter name: 'processed_items' do |p|
        p.description = 'Number of items Ingenia has processed'
        p.type = :integer
        p.example = '1554'
      end

      req.parameter name: 'total_tag_sets' do |p|
        p.description = 'Number of tag sets you have created'
        p.type = :integer
        p.example = '2'
      end

      req.parameter name: 'processed_tag_sets' do |p|
        p.description = 'Number of tag sets Ingenia has processed'
        p.type = :integer
        p.example = '2'
      end

      req.parameter name: 'total_tags' do |p|
        p.description = 'Number of tags you have created'
        p.type = :integer
        p.example = '167'
      end      

      req.parameter name: 'processed_tags' do |p|
        p.description = 'Number of tags Ingenia has processed'
        p.type = :integer
        p.example = '167'
      end

      req.parameter name: 'ready_to_classify' do |p|
        p.description = 'It will be true if all your data has been processed'
        p.type = :boolean
        p.example = 'yes'
      end

    end
    
    r.request name: 'Clear_data' do |req|
      req.description = 'View a single tag set'
      req.call_type = :post
      req.path = '/clear_data'

      req.parameter name: 'item_count' do |p|
        p.description = 'Number of items you have that are about to be deleted'
        p.type = :integer
        p.example = '123'
      end

      req.parameter name: 'tag_set_count' do |p|
        p.description = 'Number of tag sets you have that are about to be deleted'
        p.type = :integer
        p.example = '4'
      end

      req.parameter name: 'tag_count' do |p|
        p.description = 'Number of tags you have that are about to be deleted'
        p.type = :integer
        p.example = '6502'
      end      

    end

  end

end

@api = api

api.to_json
