$: << '../../lib'


$LOAD_PATH << '.'
require 'bundler/setup'
require 'doc_smoosher'

extend DocSmoosher::TopLevel

# Shared fields
limit = define_parameter(name: 'limit') do |p|
  p.description = 'Return these many results'
  p.type        = :integer
  p.default     = 10
end

offset = define_parameter(name: 'offset') do |p|
  p.description = 'Offset the results I receive by this amount'
  p.type        = :integer
  p.default     = 0
end

api_key = define_parameter(name: 'api_key') do |p|
  p.description = 'Use this API key'
  p.type        = :string
  p.required    = true
  p.example     = "hg7JHG6daSgf56FjhgsSa"
end

full_text = define_parameter(name: 'full_text') do |p|
  p.description = 'Show the results with all their text, however long'
  p.type        = :boolean
  p.default     = false
end

metadata    = define_parameter(name: 'metadata') do |m|
  m.description = <<-DESC
  A list of attributes you can associate to the knowledge item.

  Valid types of metadata are date, string, collection and number.
  'date': which includes a time for when an event occurred
  'string': General purpose content
  'collection': One item from defined collection
  'number': A numerical value

  DESC

  m.type    = :array
  m.example = "[{ name: 'published_date', type: 'date', content: '2012-01-20 00:00:00' }, { name: 'title', type: 'string', content: 'A day to remember',  { name: 'author', type: 'collection', content: 'Joe Bloggs' },      { name: 'author', type: 'collection', content: 'John Smith' }]"
end


##
# Introduction
#

DESCRIPTION =<<-DESC
  <p>Check out the <a href="/pages/demo"> demo </a> to see Ingenia in action.</p>

  <p>Look at the <a href="/faq">FAQ</a> for any questions.</p>

  <p> Go through the documentation and choose if you want to use Ingenia by the API or with the Ruby gem. </p>

  <p> <a href="/contact"> Contact us </a> to get your API key or if you have any questions.</p>

  <p>If you would like to verify your API key or code data path then use the <a href="#call-administrative-calls-status">status</a> call.</p>

  <h3 id='api-libraries'>Ruby API library</h3>
  <a href="https://github.com/ingenia-api/ingenia_ruby">https://github.com/ingenia-api/ingenia_ruby</a>

  <h3 id='api-rate-limiting'>Rate limiting</h3>

  <p>Ingenia by default limits a user to 4 calls per second, for every type of API call. Contact us to have this limit increased or removed if needed. </p>
DESC

json_similarity_response = define_object(name: 'Similarity response') do |sr|

  sr.description = "An array of items that are related to an origin item sent via a similarity API call"

  sr.parameter name: 'id' do |p|
    p.description = 'The ID of the origin item'
    p.type        = :string
  end

  sr.parameter name: 'text' do |p|
    p.description = 'First 50 characters of the text of each related item'
    p.type        = :string
  end

  sr.parameter name: 'mode' do |p|
    p.description = 'If \'tag\', it will determine related items on the basis of their tags; if \'word\', it will do so on the basis of the words contained in the item'
    p.type        = :string
    p.default     = 'tag'
  end

  sr.parameter name: 'similarity' do |p|
    p.description = 'From 0 to 1, it measures how similar each related item is to the origin item; the response will sort items on descending similarity'
    p.type        = :float
  end

  sr.example = '
  {
    [
      { "item": { "id":12182, "text": "The fall in the rand has given wealthy Russians a new location to search for luxury..." }, "mode": "tag", "similarity": 0.62 },
      { "item": { "id":9293, "text": "Robots tend to do jobs that no one wants to do. I am old enough to remember..."  }, "mode": "tag", "similarity": 0.55 },
      { "item": { "id":25333, "text": "The market for RMB credit raised outside China has gone four weeks without a..." }, "mode": "word", "similariy": 0.22 }
    ]
  }'
end

# bundle
json_bundle              = define_object(name: 'Bundle: create / update input') do |bundle|
  bundle.description = "A collection of items related to each other"
  bundle.type        = :json
  bundle.parameter name: 'name' do |p|
    p.description = 'The name of your bundle'
    p.type        = :string
  end

  bundle.this_is_json!

  bundle.parameter name: 'tag_set_ids' do |p|
    p.description =<<-DESC
    An array of tag set IDs to be applied to this bundle. The tags in these tag sets will be available to the items in the bundle.
    If an existing bundle already has tag sets, then these can be removed by omitting the ID in the call.
    DESC
    p.type = :array
  end

  bundle.example = '
  {
    "name":"Tech Startups",
    "tag_set_ids": [ 232, 332, 6582 ]
  }'
end

json_bundle_show = define_object(name: 'Bundle: show output') do |bundle|
  bundle.description = "A collection of items related to each other"
  bundle.parameter name: 'id' do |p|
    p.description = 'A unique numeric id generated by Ingenia'
    p.default     = '[generated]'
    p.type        = :numeric
  end

  bundle.parameter name: 'name' do |p|
    p.description = 'The name of your bundle'
    p.type        = :string
  end

  bundle.parameter name: 'tag_sets' do |ts|
    ts.description = 'The tag sets that are currently attached to this bundle. Items within the bundle can use all the tags in these tag sets.'
    ts.type        = :array
  end

  bundle.parameter name: 'language' do |p|
    p.description = 'The language of your bundle'
    p.type        = :string
  end

  bundle.parameter name: 'created_at' do |p|
    p.description = 'When this bundle was created'
    p.type        = :date_time
    p.example     = '2013-12-16T11:24:52+00:00'
  end

  #We should probably not show this to the user
  bundle.parameter name: 'updated_at' do |p|
    p.description = 'When this bundle was last updated'
    p.type        = :date_time
    p.example     = '2013-12-16T11:25:52+00:00'
  end

  bundle.example = '
  {
    "id":47858,
    "name":"Tech Startups",
    "tag_sets": [
      { "name": "technology", "id": 14562 },
      { "name": "business", "id": 666 }
    ],
    "language": "en",
    "created_at":"2014-03-13T15:36:51Z",
    "updated_at":"2014-03-13T15:36:51Z",
  }'
end

json_basic_response = define_object(name: 'Basic response format') do |brf|

  brf.description = "All responses from the API gateway have the following format"

  brf.parameter name: 'version' do |p|
    p.description = 'The version of the API that is responding'
    p.type        = :string
    p.example     = '"2.0"'
  end

  #data
  brf.parameter name: 'data' do |p|
    p.description = 'The data payload response from the call'
    p.type        = :object
  end


  #status
  brf.parameter name: 'status' do |p|
    p.description = '"okay" if the call is processed correctly, otherwise it will be "error"'
    p.type        = :string
  end

  #message
  brf.parameter name: 'message' do |p|
    p.description = 'A message describing the nature of the error, returned if an error occurred'
    p.type        = :string
  end

end

# Item JSON POST form
json_item           = define_object(name: 'Item: create / update input') do |item|
  item.description = "An item is a block of text to which you can associate tags, that belongs to a bundle"
  item.type        = :json

  item.this_is_json!

  item.parameter name: 'id' do |p|
    p.description = 'An alphanumeric id unique to each bundle. You can use your own, or have Ingenia generate one for you'
    p.default     = '[generated]'
    p.type        = :string
    p.example     = '785uU423aC'
  end

  item.parameter name: 'text' do |p|
    p.description = 'Your item\'s content. [1]'
    p.type        = :string
  end

  item.parameter name: 'url' do |p|
    p.description = 'Source URL to get text from. Ingenia will extract the most relevant text [1]'
    p.type        = :string
    p.example     = 'http://www.example.com'
  end

  item.parameter name: 'bundle_id' do |p|
    p.description = 'ID of the bundle in which to put the item'
    p.type        = :integer
    p.default     = '[user\'s first bundle]'
  end

  item.parameter name: 'tag_sets' do |p|
    p.description = "A hash of tag sets, each of which is an array of tags that you consider of the same type [2]"
    p.type        = :hash
    p.example     = '{ "topics": [ "startups", "saas", "marketing" ], "geography": [ "United Kingdom", "Italy" ] }'
  end

  item.parameter name: 'tags' do |p|
    p.description = "An array with the name of the tags you wish to assign to this item. If the tag doesn\'t exist, it will be created [2]."
    p.type        = :array
    p.example     = <<-EOF
[ "startups", "saas", "marketing" ]'
    EOF
  end

  item.parameter name: 'tags' do |p|
    p.description = "As above, but with a user-assigned score. The score should be a number between 0 and 1 that quantifies the strength of the association between the item and the tag (1: highest) [2]."
    p.type        = :hash
    p.example     = <<-EOF
{ "startups" : 0.2 , "sass" : 0.7, "marketing" : 1 }
    EOF
  end

  item.parameter name: 'tag_ids' do |p|
    p.description = "The Ingenia IDs of the tags you wish to assign to this item [2]"
    p.type        = :array
    p.example     = '[ 45, 787, 23 ]'
  end

  item.example = <<-EXAMPLE
  {
    text: "High tech startups and their positive power to change for good",
    tag_sets: {
      "Topics": [ "startups", "technology" ],
      "Mood": [ "positive" ]
    }
  }
  EXAMPLE

  item.parameter metadata

  item.footnote =<<-FN
    <p>[1] You can input content as one of these fields: text, a URL, a file. Formats
    supported for files include txt, html, pdf and all MS Office formats. If you send a file, it will extract the text
    from it.</p>
    <p>The text and the URL are input as part of the JSON component. The file
    is sent as a multipart encoded http field.</p>

    <p>[2] Only specify one of the following: tag_sets, tags or tag_ids </p>
  FN

end

# Item JSON get form
json_item_show      = define_object(name: 'Item: show output') do |item|
  item.parameter name: 'id' do |p|
    p.description = 'A unique alphanumeric id'
    p.type        = :string
    p.example     = '785uU423aC'
  end

  item.parameter name: 'text' do |p|
    p.description = 'Your item\'s content'
    p.type        = :string
  end

  item.parameter name: 'created_at' do |p|
    p.description = 'When this item was created'
    p.type        = :date_time
    p.example     = '2013-12-16T11:24:52+00:00'
  end

  #We should probably not show this to the user
  item.parameter name: 'updated_at' do |p|
    p.description = 'When this item was last updated'
    p.type        = :date_time
    p.example     = '2013-12-16T11:25:52+00:00'
  end

  item.parameter name: 'last_classified_at' do |p|
    p.description = 'When this item was last classified by the system; null if it hasn\'t been classified yet'
    p.type        = :date_time
    p.example     = '2013-12-16T11:25:52+00:00'
  end

  item.parameter name: 'tag_sets' do |p|
    p.description = 'An array of tag sets associated to the item'
    p.type        = :array
  end

  item.parameter name: 'tag_set' do |p|
    p.description = 'A hash containing the tag set id and the array of tags associated to the item'
    p.type        = :hash
  end

  item.parameter name: 'tag' do |p|
    p.description = 'A hash with the details of a tag associated to the item, including its id, name, user assigned score and user_selected'
    p.type        = :hash
  end

  item.parameter name: 'score' do |p|
    p.description = 'An aggregation of the machine and rule scores, between 0 (lowest) and 1 (highest).'
    p.type        = :numeric
  end

  item.parameter name: 'user_selected' do |p|
    p.description = 'Deprecated: please use user_assigned value, this will be removed in the next release'
    p.type        = :string
  end

  item.parameter name: 'user_assigned' do |p|
    p.description = 'true if the tag was assigned to the item by the user, false if it was assigned by Ingenia'
    p.type        = :boolean
  end

  item.parameter name: 'user_assigned_score' do |p|
    p.description = 'score assigned by the user when tag was created'
    p.type        = :float
  end

  item.parameter name: 'machine_score' do |p|
    p.description = 'A number which quantifies the strength of the association between an item and a tag, between 0 (lowest) and 1 (highest)'
    p.type        = :numeric
  end

  item.parameter name: 'rule_score' do |p|
    p.description = 'A number which quantifies the strength of the association between an item and a tag score, between -1 (lowest) and 1 (highest)'
    p.type        = :numeric
  end

  item.parameter name: 'membership_degree' do |p|
    p.description = 'the degree to which this item is a member of its bundle'
    p.type        = :float
  end

  item.example = '
  {
    "id":"e19e134d0e79153349ff78a674283e0b",
    "last_classified_at":2013-12-16T11:25:07+00:00,
    "text":"How to get to scale with a saas startup in the UK? ...",
    "tag_sets":
      [
        {
          "topics":
          {
            "id":156,
            "tags":
              [
                {
                  "id":4352,
                  "name":"startups",
                  "user_selected": "f",
                  "user_assigned": false,
                  "score":"0.8",
                  "machine_score":"0.45",
                  "rule_score": "0.35",
                  "user_assigned_score": null
                },
                {
                  "id": 7811,
                  "name": "saas",
                  "user_selected": "t",
                  "user_assigned": true,
                  "score": "0.45",
                  "machine_score":"0.45",
                  "rule_score": null,
                  "user_assigned_score": 0.7
                },
                {
                  "id":1327,
                  "name":"marketing",
                  "user_selected": "t",
                  "user_assigned": true,
                  "score": "0.50",
                  "machine_score":"0.45",
                  "rule_score": "0.05",
                  "user_assigned_score": 0.7
                }
              ]
          }
        },
        {
          "geography":
          {
            "id":622,
            "tags":
              [
                {
                  "id":3321,
                  "name":"united kingdom",
                  "score":"0.37",
                  "user_selected": "t",
                  "user_assigned": true
                }
              ]
          }
        }
      ]
    "created_at":"2013-12-16T11:24:52+00:00",
    "updated_at":"2013-12-16T11:24:56+00:00"
  }'
end

# Tag JSON POST form
json_tag            = define_object(name: 'Tag: create / update input') do |tag|
  tag.description = "Something you want to associate to an item, e.g., a concept, topic, tone, sentiment, keyword, person, company, product, etc."
  tag.type        = :json
  tag.this_is_json!

  tag.parameter name: 'name' do |p|
    p.description = 'The name of your tag; we advise to make it short but meaningful; unique to each tag set'
    p.type        = :string
    p.required    = true
  end

  tag.parameter name: 'tag_set_id' do |p|
    p.description = 'The ID of the tag_set to which this tag belongs'
    p.type        = :integer
    p.required    = true
  end

  tag.parameter name: 'description' do |p|
    p.description = "A description of this tag: this is helpful to define in a focused way how the tag should be used"
    p.type        = :string
  end

  tag.parameter name: 'disposition' do |p|
    p.description = "The disposition of the tag. Float value between 0 and 1, defaults to 0.5. Lower values will tend to privilege precision (we suggest 0.25); higher values will tend to privilege recall (we suggest 0.75). For most uses, the default value will work well.

You will want to privilege precision (with a disposition < 0.5) if you want each tag assignment to be accurate, and are less worried about some items being missed, i.e., you prefer to have false negatives than false positives. If the disposition is 0, no item will be tagged with this tag.

You will want to privilege recall (with a disposition > 0.5) if you want each tag assignment to occur, and are less worried about some items being tagged incorrectly, i.e., you prefer to have false positives than false negatives. If the disposition is 1, all items will be tagged with this tag."
    p.type        = :float
    p.default     = 0.5
  end

  tag.example = '
  {
    "name":"Text Analytics",
    "tag_set_id":37874,
    "description":"A set of techniques designed to extract valuable information from textual content",
    "disposition": 0.5
  }'
end

json_tag_show = define_object(name: 'Tag: show output') do |tag|
  tag.description = "Something you want to associate to an item, e.g., a concept, topic, tone, sentiment, keyword, person, company, product, etc."

  tag.parameter name: 'id' do |p|
    p.description = 'A unique numeric id, generated by Ingenia'
    p.type        = :numeric
  end

  tag.parameter name: 'name' do |p|
    p.description = 'The name of your tag'
    p.type        = :string
  end

  tag.parameter name: 'tag_set_id' do |p|
    p.description = 'The ID of the tag_set to which this tag belongs'
    p.type        = :integer
  end

  tag.parameter name: 'confidence' do |p|
    p.description = "From 0 to 1; confidence gets closer to 1 the more Ingenia considers the training for this tag sufficient; if this value is low, we advise to increase your training set for this tag"
    p.type        = :float
  end

  tag.parameter name: 'consistency' do |p|
    p.description = "From 0 to 1; consistency gets closer to 1 the more Ingenia considers the items associated to this tag as similar to one another; if this value is low, we advise to re-assess the items associated to this tag"
    p.type        = :float
  end

  tag.parameter name: 'description' do |p|
    p.description = "A description of this tag"
    p.type        = :string
  end

  tag.parameter name: 'created_at' do |p|
    p.description = 'When this tag was created'
    p.type        = :date_time
    p.example     = '2013-12-16T11:24:52+00:00'
  end

  #We should probably not show this to the user
  tag.parameter name: 'updated_at' do |p|
    p.description = 'When this tag was last updated'
    p.type        = :date_time
    p.example     = '2013-12-16T11:25:52+00:00'
  end

  tag.example = '
  {
    "id":554273,
    "name":"Text Analytics",
    "tag_set_id":8547,
    "confidence":0.95,
    "consistency":0.92,
    "description":"",
    "created_at":"2014-03-13T12:59:32Z",
    "updated_at":"2014-03-13T12:59:32Z"
  }'
end

json_tag_rules_show = define_object(name: 'Tag Rules: index output') do |tag_rule|
  tag_rule.description = "A list of rules applied to a tag to influence whether or not to apply the tag to an item."

  tag_rule.parameter name: 'tag:id' do |p|
    p.description = 'The ID of the tag to which this tag rule belongs'
    p.type        = :integer
  end

  tag_rule.parameter name: 'tag:name' do |p|
    p.description = 'The name of the tag to which this tag rule belongs'
    p.type        = :string
  end

  tag_rule.parameter name: 'tag_rules:(array):id' do |p|
    p.description = 'A unique numeric id, generated by Ingenia'
    p.type        = :numeric
  end

  tag_rule.parameter name: 'tag_rules:(array):text' do |p|
    p.description = 'The word or phrase to which the rule should apply.'
    p.type        = :string
  end

  tag_rule.parameter name: 'tag_rules:(array):language' do |p|
    p.description = 'The language of the word you\'ve entered.'
    p.type        = :string
  end

  tag_rule.parameter name: 'tag_rules:(array):influence' do |p|
    p.description = 'A number from -1 to 1, it indicates the "strength" of the rule.'
    p.type        = :float
  end

  tag_rule.parameter name: 'tag_rules:(array):tag_rule_mode' do |p|
    p.description = 'The tag rule mode used. Options are; word_present, word_absent, word_skipped or word_capped'
    p.type        = :float
  end

  tag_rule.parameter name: 'tag_rules:(array):created_at' do |p|
    p.description = 'When this tag rule was created'
    p.type        = :date_time
    p.example     = '2013-12-16T11:24:52+00:00'
  end

  tag_rule.parameter name: 'tag_rules:(array):updated_at' do |p|
    p.description = 'When this tag rule was last updated'
    p.type        = :date_time
    p.example     = '2013-12-16T11:25:52+00:00'
  end

  tag_rule.example = '
  {
    "tag": {
      id":554273,
      "name":"Text Analytics",
    },
    "tag_rule": [{
      "text": "data",
      "influence": 0.4,
      "language": "en",
      "tag_rule_mode":"word_present",
      "created_at":"2014-03-13T12:59:32Z",
      "updated_at":"2014-03-13T12:59:32Z"
    },
    ...
    ]
  }'
end

json_tag_rule_show = define_object(name: 'Tag Rule: show output') do |tag_rule|
  tag_rule.description = "A rule applied to a tag to influence whether or not to apply the tag to an item."

  tag_rule.parameter name: 'tag:id' do |p|
    p.description = 'The ID of the tag to which this tag rule belongs'
    p.type        = :integer
  end

  tag_rule.parameter name: 'tag:name' do |p|
    p.description = 'The name of the tag to which this tag rule belongs'
    p.type        = :string
  end

  tag_rule.parameter name: 'tag_rule:id' do |p|
    p.description = 'A unique numeric id, generated by Ingenia'
    p.type        = :numeric
  end

  tag_rule.parameter name: 'tag_rule:text' do |p|
    p.description = 'The word or phrase to which the rule should apply.'
    p.type        = :string
  end

  tag_rule.parameter name: 'tag_rule:language' do |p|
    p.description = 'The language of the word you\'ve entered.'
    p.type        = :string
  end

  tag_rule.parameter name: 'tag_rule:influence' do |p|
    p.description = 'A number from -1 to 1, it indicates the "strength" of the rule.'
    p.type        = :float
  end

  tag_rule.parameter name: 'tag_rule:tag_rule_mode' do |p|
    p.description = 'The tag rule mode used. Options are; word_present, word_absent, word_skipped or word_capped'
    p.type        = :string
  end

  tag_rule.parameter name: 'tag_rule:created_at' do |p|
    p.description = 'When this tag rule was created'
    p.type        = :date_time
    p.example     = '2013-12-16T11:24:52+00:00'
  end

  tag_rule.parameter name: 'tag_rule:updated_at' do |p|
    p.description = 'When this tag rule was last updated'
    p.type        = :date_time
    p.example     = '2013-12-16T11:25:52+00:00'
  end

  tag_rule.example = '
  {
    "tag": {
      id":554273,
      "name":"Text Analytics",
    },
    "tag_rule": {
      "text": "data",
      "influence": 0.4,
      "language": "en",
      "tag_rule_mode":"word_present",
      "created_at":"2014-03-13T12:59:32Z",
      "updated_at":"2014-03-13T12:59:32Z"
    }
  }'
end

# TagRule JSON POST form
json_tag_rule_create = define_object(name: 'Tag rule: create input') do |tag_rule|
  tag_rule.description = "A rule to apply to a tag to influence use of that tag."
  tag_rule.type        = :json
  tag_rule.this_is_json!

  tag_rule.parameter name: 'text' do |p|
    p.description = 'The word or phrase to which the rule should apply.'
    p.type        = :string
  end

  tag_rule.parameter name: 'language' do |p|
    p.description = 'The language of the word you\'ve entered.'
    p.type        = :string
  end

  tag_rule.parameter name: 'influence' do |p|
    p.description = 'A number from -1 to 1, it indicates the "strength" of the rule.'
    p.type        = :float
  end

  tag_rule.parameter name: 'tag_rule_mode' do |p|
    p.description = 'The tag rule mode used. Options are; word_present, word_absent, word_skipped or word_capped'
    p.type        = :string
  end

  tag_rule.example = '
  {
    "text":"ruby",
    "influence":0.5,
    "language":"en",
    "tag_rule_mode":"word_present"
  }'
end

# TagSet JSON POST form
json_tag_set         = define_object(name: 'Tag set: create / update input') do |tag_set|
  tag_set.description = "A collection of thematically consistent tags"
  tag_set.type        = :json
  tag_set.this_is_json!

  tag_set.parameter name: 'name' do |p|
    p.description = 'The name of your tag set; we advise to make it short but meaningful; must be unique'
    p.type        = :string
  end

  tag_set.example = '
  {
    "name":"Big Data"
  }'
end

json_tag_set_show = define_object(name: 'Tag set: show output') do |tag_set|
  tag_set.description = "A collection of thematically consistent tags"

  tag_set.parameter name: 'id' do |p|
    p.description = 'A unique numeric id, generated by Ingenia'
    p.type        = :numeric
  end

  tag_set.parameter name: 'name' do |p|
    p.description = 'The name of your tag set'
    p.type        = :string
  end

  tag_set.parameter name: 'created_at' do |p|
    p.description = 'When this tag set was created'
    p.type        = :date_time
    p.example     = '2013-12-16T11:24:52+00:00'
  end

  #We should probably not show this to the user
  tag_set.parameter name: 'updated_at' do |p|
    p.description = 'When this tag set was last updated'
    p.type        = :date_time
    p.example     = '2013-12-16T11:25:52+00:00'
  end

  tag_set.example = '
  {
    "id":178751,
    "name":"Big Data",
    "created_at":"2014-03-12T12:17:33Z",
    "updated_at":"2014-03-12T12:17:33Z"
  }'
end

# Classifications
json_classify     = define_object(name: 'Classifications') do |classify|

  classify.example = '
{
  "api_version": "2.0",
  "status": "okay",

  "data": {
    "classification_status": "complete",
    "results": {

      "Software": {
        "id": 6,
        "tags": [
          {
            "id": 31,
            "name": "php",
            "score": 0.655
          },
          {
            "id": 90,
            "name": "php-session",
            "score": 0.315
          },
          {
            "id": 158,
            "name": "pass-by-reference",
            "score": 0.262
          },
          {
            "id": 160,
            "name": "debugging",
            "score": 0.24
          },
          {
            "id": 159,
            "name": "pass-by-value",
            "score": 0.198
          },
          {
            "id": 63,
            "name": "apache",
            "score": 0.132
          }
        ]
      }
    }
  }
}
'

end


define_api(name: 'Ingenia API', description: DESCRIPTION) do |api|

  api.endpoint = 'api.ingeniapi.com/v2/'
  api.version  = '2.0'
  api.format   = 'json'

  api.object json_basic_response
  api.object json_item
  api.object json_item_show
  api.object json_bundle
  api.object json_bundle_show
  api.object json_tag
  api.object json_tag_show
  api.object json_tag_set
  api.object json_tag_set_show
  api.object json_similarity_response


  api.resource name: 'Classifications' do |r|
    r.description = ""

    r.request name: 'Classify' do |req|
      req.description = ''
      req.call_type   = :post
      req.path        = '/classify'

      req.parameter name: 'text' do |p|
        p.description = 'The text you want Ingenia to classify [1]'
        p.type        = :string
        p.example     = 'A comparative study of European secondary education systems illustrated issues related to their budgetary sustainability...'
      end

      req.parameter name: 'url' do |p|
        p.description = 'The source URL from which to extract the text to be classified; Ingenia will extract the most relevant text [1]'
        p.type        = :string
        p.example     = 'http://www.example.com'
      end

      req.parameter name: 'file' do |p|
        p.description = 'File to be used as text source. Sent as multipart upload. Accepted file extensions are: Text (txt), Postscript Document Format (pdf) and Microsoft Office Documents (doc, docx, xlsx, ppt, pptx). [1]'
        p.type        = :multipart
        p.example     = 'document.pdf'
      end

      req.parameter name: 'bundle_id' do |p|
        p.description = 'ID of the bundle to which the item belongs'
        p.type        = :integer
        p.default     = '[user\'s first bundle]'
      end

      req.parameter name: 'min_tags' do |p|
        p.description = 'Return at least these many tags'
        p.type        = :integer
        p.default     = 0
      end

      req.parameter name: 'max_tags' do |p|
        p.description = 'Return at most these many tags'
        p.type        = :integer
        p.default     = 6
      end

      req.footnote = <<-FN
      <p>[1] You can input content as one of these fields: text, a URL, a file. Formats
    supported for files include txt, html, pdf and all MS Office formats. If you send a file, it will extract the text
    from it.</p>
      <p>The text and the URL are input as part of the JSON component. The file
    is sent as a multipart encoded http field.</p>
      FN
    end


  end


  ##
  # Recommendation Engine
  #

  api.resource name: 'Recommendation engine' do |r|
    r.description = ""

    # r.request name: 'Similar to' do |req|
    #   req.description = ''
    #   req.call_type = :get
    #   req.path = '/items/:id/similar_to'
    #
    #   req.parameter name: 'id' do |p|
    #     p.description = 'ID of item for which we want other similar items'
    #     p.type = :string
    #     p.required = true
    #   end
    #
    #   req.parameter limit
    #
    #   req.parameter full_text
    #
    #   req.parameter name: 'mode' do |p|
    #     p.description = 'Constrain matches to base similarity on just "tag", just "word", or "auto" (first tags, then words)'
    #     p.type = :string
    #     p.example = 'mode=tag'
    #     p.default = 'auto'
    #   end
    #
    #   req.parameter name: 'metadata_filters' do |p|
    #     p.description = 'Instruct ingenia to only consider knowledge items which match these criteria'
    #     p.type = :string
    #     p.example = 'metadata_filters[author]=Joe%20Bloggs'
    #   end
    #
    #   req.parameter name: 'item_filters' do |p|
    #     p.description = 'Instruct ingenia to only consider knowledge items which were created within specific dates. Dates are inclusive.'
    #     p.type = :string
    #     p.example = 'item_filters[from]=2014-12-25&item_filters[to]=2014-12-30'
    #   end
    #
    #   req.response = json_similarity_response
    # end

    r.request name: 'Similar to text' do |req|
      req.description = ''
      req.call_type   = :post
      req.path        = '/similar_to_text'

      req.parameter name: 'text' do |p|
        p.description = 'Text of item for which we want other similar items'
        p.type        = :string
      end

      req.parameter name: 'bundle_id' do |p|
        p.description = 'The bundle this item would most likely be found in. If this parameter is omitted, ingenia assumes the first bundle you created.'
        p.type        = :integer
        p.example     = '77'
      end

      req.parameter name: 'bundle_ids' do |p|
        p.description = 'Find similar items in one or more bundles. If this parameter is omitted, ingenia find items from any of your bundles.'
        p.type        = :array
        p.example     = '1,4,77'
      end

      req.parameter name: 'limit' do |p|
        p.description = 'The number of items to return, the maximum is 100.'
        p.type = :integer
        p.example = '15'
      end

      req.parameter full_text

      req.parameter name: 'mode' do |p|
        p.description = 'Constrain matches to base similarity on just "tag", just "word", or "auto" (first tags, then words)'
        p.type        = :string
        p.example     = 'mode=tag'
        p.default     = 'auto'
      end

      req.parameter name: 'metadata_filters' do |p|
        p.description = 'Instruct ingenia to only consider knowledge items which match these criteria'
        p.type        = :string
        p.example     = 'metadata_filters[author]=Joe%20Bloggs'
      end

      req.parameter name: 'item_filters' do |p|
        p.description = 'Instruct ingenia to only consider knowledge items which were created within specific dates. Dates are inclusive.'
        p.type        = :string
        p.example     = 'item_filters[from]=2014-12-25&item_filters[to]=2014-12-30'
      end

      req.response = json_similarity_response
    end


    r.request name: 'Similar to tags' do |req|
      req.description = ''
      req.call_type   = :get
      req.path        = '/similar_to_tags'

      req.parameter name: 'tag_ids' do |p|
        p.description = 'JSON encoded array of tag IDs for which we want relevant items'
        p.type        = :array
        p.example     = '[ 45, 787, 23 ]'
      end

      req.parameter name: 'bundle_ids' do |p|
        p.description = 'Find similar items in one or more bundles. If this parameter is omitted, ingenia will attempt to infer the bundles from the tags'
        p.type        = :array
        p.example     = '1,4,77'
      end

      req.parameter name: 'limit' do |p|
        p.description = 'The number of items to return, the maximum is 100.'
        p.type = :integer
        p.example = '15'
      end

      req.parameter full_text

      req.parameter name: 'metadata_filters' do |p|
        p.description = 'Instruct ingenia to only consider knowledge items which match these criteria'
        p.type        = :string
        p.example     = 'metadata_filters[author]=Joe%20Bloggs'
      end

      req.parameter name: 'item_filters' do |p|
        p.description = 'Instruct ingenia to only consider knowledge items which were created within specific dates. Dates are inclusive.'
        p.type        = :string
        p.example     = 'item_filters[from]=2014-12-25&item_filters[to]=2014-12-30'
      end

      req.response = json_similarity_response
    end


  end

  ##
  # Summarization
  #
  api.resource name: 'Summarisation' do |r|
    r.description = ""

    r.request name: 'Summarise' do |req|
      req.description = '<code class="get_post">GET</code> is also supported'
      req.call_type   = :post
      req.path        = '/summarise'

      req.parameter name: 'text' do |p|
        p.description = 'Text to summarise: the key sentences will be extracted'
        p.type        = :string
      end

      req.parameter name: 'id' do |p|
        p.description = 'ID of the item to be summarised.'
        p.type        = :string
      end

      req.parameter name: 'include_tags' do |p|
        p.description = 'If true the resulting sentences will be organised by each tag associated to the text, if false they are returned as a list'
        p.type        = :boolean
        p.default     = true
      end

      req.parameter name: 'order_by_position' do |p|
        p.description = 'If true, the results will be ordered as they appear in the text, if false, they will be ordered by the score of the sentence'
        p.type        = :boolean
        p.default     = 'false'
      end

      req.parameter name: 'max_sentences' do |p|
        p.description = 'Maximum number of sentences to return'
        p.type        = :integer
        p.default     = 2
      end

    end

  end


  ##
  # Items
  #
  api.resource name: 'Items' do |r|
    r.description = "Blocks of textual content, typically self-contained and homogeneous"

    r.request name: 'Index' do |req|
      req.description = 'Returns a list of all your items'
      req.call_type   = :get
      req.path        = '/items'

      #req.parameter api_key
      req.parameter limit
      req.parameter full_text
      req.parameter offset

      #req.response = { :array => json_item_show.example }
    end


    r.request name: 'Show' do |req|
      req.description = 'Returns a single item'
      req.call_type   = :get
      req.path        = '/items/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the item you want to show'
        p.type        = :string
        p.required    = true
      end
      #req.parameter api_key
      req.parameter full_text

      req.response = json_item_show
    end

    r.request name: 'Create' do |req|
      req.description = 'Creates a new item'
      req.call_type   = :post
      req.path        = '/items'


      req.parameter json_item

      req.parameter name: 'file' do |p|
        p.description = 'File to be used as text source. Sent as multipart upload. Accepted file extensions are: Text (txt), Postscript Document Format (pdf) and Microsoft Office Documents (doc, docx, xlsx, ppt, pptx). [1]'
        p.type        = :multipart
      end

      req.parameter name: 'update_existing' do |p|
        p.description = 'Choice of what to do if the item sent via a create call already exists on Ingenia, as determined by its item ID. If this field is true, the tags supplied will overwrite those on the existing item. If false, no data is modified and a response is returned with a 409 code (Conflict) together with the existing item as JSON.'
        p.default     = true
        p.type        = :boolean
      end

      req.parameter name: 'classify' do |p|
        p.description = 'If true, the response will also include a classification'
        p.default     = false
        p.type        = :boolean
      end

      req.footnote =<<-FN
        <p>[1] You can input content as one of these fields: text, a URL, a file. Formats
        supported for files include txt, html, pdf and all MS Office formats. If you send a file, it will extract the text
        from it.</p>
        <p>The text and the URL are input as part of the JSON component. The file
        is sent as a multipart encoded http field.</p>

      FN

      req.example = <<-EOF
# Simply post item's text
curl -X POST \\
  -F'json={ "text" : "Some inline text" }' \\
  'http://api.ingeniapi.com/v2/items?api_key=$api_key&classify=true'

# Create an item with some text and assign a tag ('foo') to it with a score of 0.2.
curl -X POST \\
  -F'json={ "text" : "Some inline text" , "tags" : { "foo" : 0.2 } }' \\
  'http://api.ingeniapi.com/v2/items?api_key=$api_key&classify=true'

# Create an item with some text, create a new tag set ('my tag set') and add
# a tag ('foo') with a score of 0.2 to that tag set..
curl -X POST \\
  -F'json={ "text" : "Some inline text" , "tag_sets" : { "my tag set" :  { "foo" : 0.2 } } }' \\
  'http://api.ingeniapi.com/v2/items?api_key=$api_key&classify=true'

# Create an item with the tag ('foo')
curl -X POST \\
  -F'json={ "text" : "Some inline text" , "tags" : [ "foo"]  }' \\
  'http://api.ingeniapi.com/v2/items=$api_key&classify=true'

# Post url to retrieve content from and create an item with that content
curl -X POST \\
  -F'json={ "url" : "http://www.zdziarski.com/blog/?p=3875" }' \\
  'http://api.ingeniapi.com/v2/items?api_key=$api_key'

# Post a file using multipart/form-data upload and create an item with that content
curl -X POST \\
  -F'json={}' \\
  -F'file=@article.txt' \\
  'http://api.ingeniapi.com/v2/items?api_key=$api_key&classify=true&update_existing=true'
      EOF


    end

    r.request name: 'Update' do |req|
      req.description = 'Update an existing item'
      req.call_type   = :put
      req.path        = '/items/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the item you want to update'
        p.type        = :string
        p.required    = true
      end

      req.parameter json_item

      req.parameter name: 'file' do |p|
        p.description = 'File to be used as text source. Sent as multipart upload. Accepted file types are: Text (txt), Postscript Document Format (pdf), Microsoft Office Documents (doc, docx, xls, xlsx, ppt, pptx). [1]'
        p.type        = :multipart
      end

      req.footnote =<<-FN
        <p>[1] You can input content as ONE of: text, a URL, a file (formats
        supported include txt, html, pdf, all the MS Office formats). If you
        send a URL, Ingenia will extract the most meaningful text from it,
        e.g., ignoring links. If you send a file, it will extract the text
        from it.</p>
        <p>The text and the URL are input as part of the JSON component. The file
        is sent as a multipart encoded http field.</p>
      FN
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing item'
      req.call_type   = :delete
      req.path        = '/items/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the item you want to delete'
        p.type        = :string
        p.required    = true
      end
    end

    r.request name: 'Similar to' do |req|
      req.description = ''
      req.call_type   = :get
      req.path        = '/items/:id/similar_to'

      req.parameter name: 'id' do |p|
        p.description = 'ID of item to get similar items to'
        p.type        = :string
        p.required    = true
      end

      req.parameter name: 'bundle_id' do |p|
        p.description = 'Tell ingenia which bundle this item is in. If this parameter is omitted, ingenia will only look for the item in the default bundle'
        p.type        = :integer
        p.example     = '77'
      end

      req.parameter name: 'bundle_ids' do |p|
        p.description = 'Restrict your search to one or more bundles. If this parameter is omitted, all bundles will be scanned'
        p.type        = :array
        p.example     = '1,4,77'
      end

      req.parameter name: 'limit' do |p|
        p.description = 'The number of items to return, the maximum is 100.'
        p.type = :integer
        p.example = '15'
      end


      req.parameter full_text

      req.parameter name: 'mode' do |p|
        p.description = 'Constrain matches to base similarity on just "tag", just "word", or "auto" (first tags, then words)'
        p.type        = :string
        p.example     = 'mode=tag'
        p.default     = 'auto'
      end

      req.parameter name: 'metadata_filters' do |p|
        p.description = 'Instruct ingenia to only consider knowledge items which match these criteria'
        p.type        = :string
        p.example     = 'metadata_filters[author]=Joe%20Bloggs'
      end

      req.parameter name: 'item_filters' do |p|
        p.description = 'Instruct ingenia to only consider knowledge items which were created within specific dates. Dates are inclusive.'
        p.type        = :string
        p.example     = 'item_filters[from]=2014-12-25&item_filters[to]=2014-12-30'
      end

      req.response = json_similarity_response
    end
  end

  ##
  # Bundles
  #
  api.resource name: 'Bundles' do |r|
    r.description = "Groups of thematically consistent items"

    r.request name: 'Index' do |req|
      req.description = 'Returns a list of all your bundles'
      req.call_type   = :get
      req.path        = '/bundles'
      req.parameter limit
      req.parameter offset
      req.example = <<-EOF
curl http://api.ingeniapi.com/v2/bundles?api_key=$api_key

'{
  [
    {
      "created_at" : "2016-04-06T09:00:44Z",
      "id":755,
      "name":"New Bundle",
      "updated_at":"2016-04-06T09:00:44Z"
    },
    {
      "created_at" : "2016-04-07T11:44:26Z",
      "id" : 756,
      "name" : "Another Bundle",
      "updated_at":"2016-04-07T11:44:26Z"
    }
  ]
}'
      EOF
    end

    r.request name: 'Show' do |req|
      req.description = 'Returns a single bundle'
      req.call_type   = :get
      req.path        = '/bundles/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the bundle you want to show'
        p.type        = :integer
        p.required    = true
      end

      req.example = <<-EOF
curl http://api.ingeniapi.com/v2/bundles/47858?api_key=$api_key

'{
    "id" : 47858,
    "name" : "Tech Startups",
    "tag_sets" : [
      { "name" : "technology", "id": 14562 },
      { "name" : "business", "id": 666 }
    ],
    "created_at" :"2014-03-13T15:36:51Z",
    "updated_at" :"2014-03-13T15:36:51Z",
  }'
      EOF
    end

    r.request name: 'Find_by_name' do |req|
      req.description = 'Looks for a bundle that matches exactly text input'
      req.call_type   = :get
      req.path        = '/bundles/find_by_name'

      #req.parameter api_key
      req.parameter name: 'text' do |p|
        p.description = 'Text of the bundle to look for'
        p.type        = :string
      end

      req.example = <<-EOF
curl 'http://api.ingeniapi.com/v2/bundles/find_by_name?name=Tech%Startups&api_key=$api_key'

'{
    "id" : 47858,
    "name" : "Tech Startups",
    "tag_sets" : [
      { "name" : "technology", "id": 14562 },
      { "name" : "business", "id": 666 }
    ],
    "created_at" :"2014-03-13T15:36:51Z",
    "updated_at" :"2014-03-13T15:36:51Z",
  }'
      EOF
    end

    r.request name: 'Create' do |req|
      req.description = 'Creates a new bundle'
      req.call_type   = :post
      req.path        = '/bundles'
      req.parameter json_bundle
      req.example = <<-EOF
curl -X POST \\
  -F'json={ "name" : "New Bundle" }' \\
  'http://api.ingeniapi.com/v2/bundles?api_key=$api_key'

'{
    "id" : 47858,
    "name" : "New Bundle",
    "tag_sets" : [],
    "created_at" :"2014-03-13T15:36:51Z",
    "updated_at" :"2014-03-13T15:36:51Z",
  }'
      EOF
    end

    r.request name: 'Update' do |req|
      req.description = 'Update an existing bundle'
      req.call_type   = :put
      req.path        = '/bundles/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the bundle you want to update'
        p.type        = :integer
        p.required    = true
      end
      req.parameter json_bundle
      req.example = <<-EOF
curl -X PUT \\
  -F'json={ "name" : "New Bundle Updated" }' \\
  'http://api.ingeniapi.com/v2/bundles/47858?api_key=$api_key'

'{
    "id" : 47858,
    "name" : "New Bundle Updated",
    "tag_sets" : [],
    "created_at" :"2016-04-06T09:00:44Z",
    "updated_at" :"2016-04-06T09:00:44Z",
  }'
      EOF
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing bundle'
      req.call_type   = :delete
      req.path        = '/bundles/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the bundle you want to delete'
        p.type        = :integer
        p.required    = true
        req.example = <<-EOF
curl -X DELETE \\
  'http://api.ingeniapi.com/v2/bundles/47858?api_key=$api_key'

'{
    "47858" : "destroyed"
  }'
      EOF
      end
    end
  end

  ##
  # Tags
  #
  api.resource name: 'Tags' do |r|
    r.description = "Tags are meaningful words or expressions that you want to associate to some of your items"

    r.request name: 'Index' do |req|
      req.description = 'List all your tags'
      req.call_type   = :get
      req.path        = '/tags'

      req.parameter limit
      req.parameter offset
      req.example = <<-EOF
curl http://api.ingeniapi.com/v2/tags?api_key=$api_key
      EOF
    end

    r.request name: 'Show' do |req|
      req.description = 'View a single tag'
      req.call_type   = :get
      req.path        = '/tags/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag you want to show'
        p.type        = :integer
        p.required    = true
      end
      req.response = json_tag_show

    end

    r.request name: 'Find_by_name' do |req|
      req.description = 'Looks for a tag that matches exactly text input'
      req.call_type   = :get
      req.path        = '/tags/find_by_name'

      req.parameter name: 'text' do |p|
        p.description = 'Text of the tag to look for'
        p.type        = :string
      end
    end

    r.request name: 'Create' do |req|
      req.description = 'Create a new tag'
      req.call_type   = :post
      req.path        = '/tags'

      req.parameter json_tag
      req.example = <<-EOF
curl -X POST \\
  -F'json={ "tag_set_id" : 52, "name" : "wine" }' \\
  http://api.ingeniapi.com/v2/tags?api_key=$api_key
      EOF
    end

    r.request name: 'Update' do |req|
      req.description = 'Update an existing tag'
      req.call_type   = :put
      req.path        = '/tags/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag you want to update'
        p.type        = :integer
        p.required    = true
      end
      req.parameter json_tag
    end

    r.request name: 'Merge' do |req|
      req.description = 'Merge two or more existing tags'
      req.call_type   = :post
      req.path        = '/tags/:id/merge'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag into which you want to merge other tags; the resulting tag will have this name'
        p.type        = :integer
        p.required    = true
      end

      req.parameter name: 'tag_ids' do |p|
        p.description = 'A JSON encoded array of tag IDs that will be merged into the main tag'
        p.type        = :array
        p.example     = '[ 23, 43, 2113 ]'
        p.required    = true
      end

      req.example = <<-EOF
curl -X POST \\
  http://api.ingeniapi.com/v2/tags/8/merge?tag_ids='[7,8]'&api_key=$api_key
      EOF
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing tag'
      req.call_type   = :delete
      req.path        = '/tags/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag you want to delete'
        p.type        = :integer
        p.required    = true
      end
    end
  end

  ##
  # Tag rules
  #
  api.resource name: 'Tag Rules' do |r|
    r.description = "Tag Rules are rules that you want to associate with a tag to influence the tag choice"

    r.request name: 'Index' do |req|
      req.description = 'List all your tag rules for a tag'
      req.call_type   = :get
      req.path        = '/tag/:tag_id/tag_rules'

      req.response = json_tag_rules_show
      req.example  = <<-EOF
curl http://api.ingeniapi.com/v2/tag/5/tag_rules?api_key=$api_key
      EOF

      req.parameter name: 'tag_id' do |p|
        p.description = 'The ID of the tag to find its associated tag rules'
        p.type        = :integer
        p.required    = true
      end
    end

    r.request name: 'Show' do |req|
      req.description = 'View a single tag rule'
      req.call_type   = :get
      req.path        = '/tag/:tag_id/tag_rules/:id'

      req.response = json_tag_rule_show
      req.example  = <<-EOF
curl http://api.ingeniapi.com/v2/tag/5/tag_rules/6?api_key=$api_key
      EOF

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag rule'
        p.type        = :integer
        p.required    = true
      end

      req.parameter name: 'tag_id' do |p|
        p.description = 'The ID of the tag'
        p.type        = :integer
        p.required    = true
      end
    end

    r.request name: 'Create' do |req|
      req.description = 'Create a new tag rule'
      req.call_type   = :post
      req.path        = '/tag/:tag_id/tag_rules'
      req.parameter json_tag_rule_create
      req.example = <<-EOF
curl -X POST \\
  -F'json={ "text": "tag_text", "influence" : 0.3, "language": "en", "tag_rule_mode": "word_present" }' \\
  http://api.ingeniapi.com/v2/tag/5/tag_rules?api_key=$api_key
      EOF

      req.parameter name: 'tag_id' do |p|
        p.description = 'The ID of the tag'
        p.type        = :integer
        p.required    = true
      end
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing tag rule'
      req.call_type   = :delete
      req.path        = '/tag/:tag_id/tag_rules/:id'
      req.example     = <<-EOF
curl -X DELETE \\
  http://api.ingeniapi.com/v2/tag/5/tag_rules/6?api_key=$api_key
      EOF

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag rule you want to delete'
        p.type        = :integer
        p.required    = true
      end

      req.parameter name: 'tag_id' do |p|
        p.description = 'The ID of the tag'
        p.type        = :integer
        p.required    = true
      end
    end
  end

  ##
  # Tag Sets
  #
  api.resource name: 'Tag sets' do |r|
    r.description = "Tag sets are thematically consistent groups of tags defined by you, such as, say, world countries, business sectors, product types, companies, concepts, topics, etc"

    r.request name: 'Index' do |req|
      req.description = 'List all your tag sets'
      req.call_type   = :get
      req.path        = '/tag_sets'

      req.parameter limit
      req.parameter offset
      req.example = <<-EOF
# Simple request to fetch all tag sets
curl -s -q http://api.ingeniapi.com/v2/tag_sets?api_key=$api_key

# ...and a bit more advanced example
curl -s -q http://api.ingeniapi.com/v2/tag_sets?limit=100&offset=100&bundle_id=42&api_key=$api_key

'[
  {
    "created_at" : "2016-04-06T11:01:18Z",
    "id" : 2820,
    "name" : "Tag Set One",
    "updated_at" : "2016-04-06T11:04:00Z"
  },
  {
    "created_at" : "2016-04-06T09:00:44Z",
    "id" : 2819,
    "name" : "Tag Set Two",
    "updated_at":"2016-04-06T09:00:44Z"
  }
]'
      EOF
    end

    r.request name: 'Show' do |req|
      req.description = 'View a single tag set'
      req.call_type   = :get
      req.path        = '/tag_sets/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag set you want to show'
        p.type        = :integer
        p.required    = true
      end
      req.example = <<-EOF
curl http://api.ingeniapi.com/v2/tag_sets/2820?api_key=haDJdWeW41iwzEup7n8x

  '{
    "name":"Big Data"
  }'
EOF
    end

    r.request name: 'Find_by_name' do |req|
      req.description = 'Looks for a tag set that matches exactly text input'
      req.call_type   = :get
      req.path        = '/tag_sets/find_by_name'

      req.parameter name: 'text' do |p|
        p.description = 'Text of tag set to look for'
        p.type        = :string
      end
    end

    r.request name: 'Create' do |req|
      req.description = 'Create a new tag set'
      req.call_type   = :post
      req.path        = '/tag_sets'

      req.parameter json_tag_set
      req.example = <<-EOF
curl -s -X POST \\
  -F'json={ "name" : "new tag s" }' \\
  http://api.ingeniapi.com/v2/tag_sets?api_key=$api_key
      EOF
    end

    r.request name: 'Update' do |req|
      req.description = 'Update an existing tag set'
      req.call_type   = :put
      req.path        = '/tag_sets/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag set you want to update'
        p.type        = :integer
        p.required    = true
      end

      req.parameter json_tag_set
    end

    r.request name: 'Merge' do |req|
      req.description = 'Merge two or more existing tag sets'
      req.call_type   = :post
      req.path        = '/tag_sets/:id/merge'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag set into which you want to merge the other tag sets; the resulting tag set will have this name'
        p.type        = :integer
        p.required    = true
      end

      req.parameter name: 'tag_set_ids' do |p|
        p.description = 'JSON encoded array of tag set IDs to merge into main tag set'
        p.type        = :array
        p.example     = '[ 12, 34, 56 ]'
        p.required    = true
      end
    end

    r.request name: 'Delete' do |req|
      req.description = 'Delete an existing tag set'
      req.call_type   = :delete
      req.path        = '/tag_sets/:id'

      req.parameter name: 'id' do |p|
        p.description = 'The ID of the tag set you want to delete.'
        p.type        = :integer
        p.required    = true
      end
    end
  end

  ##
  # Administrative Calls
  #
  api.resource name: 'Administrative Calls' do |r|
    r.description = ""

    r.request name: 'Status' do |req|
      req.description = 'The status of your Ingenia account, indicating whether Ingenia has processed all your content; use this to test your API key, see [status call] for details'
      req.call_type   = :get
      req.path        = '/status'

      req.parameter name: 'total_bundles' do |p|
        p.description = 'Number of bundles you have own'
        p.type        = :integer
      end

      req.parameter name: 'processed_bundles' do |p|
        p.description = 'Number of bundles where all items have been processed'
        p.type        = :integer
      end

      req.parameter name: 'total_items' do |p|
        p.description = 'Number of items you have created'
        p.type        = :integer
      end

      req.parameter name: 'pending_items' do |p|
        p.description = 'Number of items Ingenia has not yet processed'
        p.type        = :integer
      end

      req.parameter name: 'processed_items' do |p|
        p.description = 'Number of items Ingenia has processed'
        p.type        = :integer
      end

      req.parameter name: 'total_tag_sets' do |p|
        p.description = 'Number of tag sets you own'
        p.type        = :integer
      end

      req.parameter name: 'processed_tag_sets' do |p|
        p.description = 'Number of tag sets Ingenia has processed'
        p.type        = :integer
      end

      req.parameter name: 'pending_tag_sets' do |p|
        p.description = 'Number of tag sets ready to process, but which Ingenia has not yet processed'
        p.type        = :integer
      end

      req.parameter name: 'untrained_tag_sets' do |p|
        p.description = 'Number of tag sets which do not have enough items to process'
        p.type        = :integer
      end

      req.parameter name: 'total_tags' do |p|
        p.description = 'Number of tags you have own'
        p.type        = :integer
      end

      req.parameter name: 'processed_tags' do |p|
        p.description = 'Number of tags Ingenia has processed'
        p.type        = :integer
      end

      req.parameter name: 'pending_tags' do |p|
        p.description = 'Number of tags Ingenia has not yet processed'
        p.type        = :integer
      end

      req.parameter name: 'untrained_tags' do |p|
        p.description = 'Number of tags which are not assigned to items'
        p.type        = :integer
      end

      req.parameter name: 'ready_to_classify' do |p|
        p.description = 'True if all tags assigned to items have been processed'
        p.type        = :boolean
      end


    end


    r.request name: 'Clear_data' do |req|
      req.description = 'Delete all the data in your account; useful to restart from zero if the data was polluted'
      req.call_type   = :post
      req.path        = '/clear_data'

      req.parameter name: 'item_count' do |p|
        p.description = 'Number of items you have that are about to be deleted'
        p.type        = :integer
      end

      req.parameter name: 'tag_set_count' do |p|
        p.description = 'Number of tag sets you have that are about to be deleted'
        p.type        = :integer
      end

      req.parameter name: 'tag_count' do |p|
        p.description = 'Number of tags you have that are about to be deleted'
        p.type        = :integer
      end

    end

  end

end

@api = api

api.to_json
